#include<stdio.h>
#include<wchar.h>
#include<stdlib.h>
#include<locale.h>
#include<wctype.h>
#include<windows.h>

/*заголовочный файл stdio.h - в данном заголовочном файле определены функции ввода - вывода, типы и макросы.
заголовочный файл wchar.h - заголовочный файл в котором находятся функции для работы со строками типа wchar_t.
заголовочный файл wctype.h - заголовочный файл в котором находятся функции для работы с символами типа wchar_t.
заголовочный файл stdlib.h - содержит функции для распределения памяти, преобразования чисел,
заголовочный файл windows.h - подключен для смены кодовой страницы для потока ввода
*/
#define BIG_ENDIAN_MARKER 0XFFFE //значение маркера определяющего кодировку UTF-16 BIG_ENDIAN
#define LITTLE_ENDIAN_MARKER 0XFEFF// значение маркера определяющего кодировку UTF-16 LITTLE_ENDIAN
#define UTF_8_BOM 0XBBEF// значение маркера определяющего кодировку UTF-8(BOM)
#define ISO_rus_11 0xD9//код буквы "й" для кодировки ISO8859-5
#define ISO_rus_12 0xDA//код буквы "к" для кодировки ISO8859-5
#define ISO_rus_13 0xDB//код буквы "л" для кодировки ISO8859-5
#define ISO_rus_14 0xDC//код буквы "м" для кодировки ISO8859-5
#define KOI8_R_7 0xA2//код буквы "ё" для кодировки KOI8-R
#define KOI8_R_F 0xA3//код буквы "F" для кодировки KOI8-R
#define KOI8_U 0xBE//код буквы в кодировке KOI8-U,существующий только в украинском языке 
#define OEM855_33 0xDE//код буквы "я" в кодировке OEM855
#define OEM855_17 0xD8//код буквы "п" в кодировке OEM855
#define OEM855_23 0xB5//код буквы "х" в кодировке OEM855
#define OEM866_33 0xEF//код буквы "я" в кодировке OEM866
struct MyStack//структура стека
{
	wchar_t *data;//строка даных
	struct MyStack *Next, *Prev;//Next-указатели на следующий  элементы стрека
	//Prev-указатели на предыдущий  элементы стрека

} *Error_Stack;// Error_Stack - указатель на стек ошибок
int Line = 1;// счетчик строк в файле
wchar_t Encoding[200] = { 0 };// строка в котрую сохраняется кодирока файла ,определенная  функцией EncodingType()

wchar_t * EncodingType();// функция определяющая кодировку файла,записывая строку с названием кодировки в  строку Encoding.Возвращает имя открытого файла

void Push(struct MyStack **Stack, wchar_t *data_in);//Функция добавления элемента в стек,возврашщает void
//Прнимает Stack - адрес указателя на стек, data_in -стока данных ,которые добавляются в стек

void ParseComment(FILE *fin);//функция осуществляет валидацию комментариев
//Принимает:fin - указатель на читаемый файл 
//визвращает void

int CheckAttribute(wchar_t**attribute_in, size_t index, wchar_t *new_attribute);// вспомогательная функция проверяет наличие аттрибута в переданном ей массиве строк
/*Параметры:
attribute_in - массив строк
index - кол-во строк в массиве
new_attribute - новый считанный аттрибут,переданый в функцию для проверки наличия данного аттрибута в массиве строк
Возвращемое значение:
Если аттрибут new_attribute найден в массиве строк то 0 ,если не найден то 1
*/

struct MyStack* ShowElement(struct MyStack **Stack);//функция возвращающая элемент ,лежащий на вершине стека без его удаления
//Прнимает Stack - адрес указателя на стек

wchar_t* Pop(struct MyStack **DelElement);//функция возвращает строку даных лежащую на вершине стека и удаляет элемент 
//Прнимает DelElement - адрес указателя на стек

int  SearchInStack(struct MyStack **Stack, wchar_t *buf_in);//функция проеряет содержится ли элемент buf_in в стеке,возвркщает 1 если элемент buf_in содержится в стеке,и 0 в противном случае
//Прнимает:
//Stack - адрес указателя на стек
//*buf_in - указатель на буфер ,содержащий имя элемента

int  GetSizeStack(struct MyStack **Stack);// Фунукция возвращает колмчество элементов лежащих в стеке
//Прнимает в качестве параметра Stack - адрес указателя на стек

void ParseProlog(FILE *fin);//функция парсинга пролога и проверка  валидации его аттрибутов.
//Принимает: fin-указатель на открытый файл

void FileRead(wchar_t * NameFile);//Основная функция чтения файла и определение его валидации,вызывает вспомогательные функции.Принимает Name_File - имя введенного файла  и возвращает void 

size_t ParseAttribute(FILE *fin);//Функция валидации аттрибутов элемента.Параметры:fin - указатель на считываемый файл
//Возврвщает size_t.Возвращаемое значение функции:0 - если аттрибуты прочитанны до символа >,1 - если отцутствует в  элементе закрывающая скобка > 

int main()
{
	wchar_t  **buf = NULL, Name[255] = { 0 };
	int Size_Err_Stack = 0,count = 0;
	/*
	Name - буфер,содержащий имя открываемого файла
	Size_Err_Stack - переменная ,в которую сохранятся количество элементов содержащихся в стеке ошибок
	buf - указатель на массив строк,для  печати ошибок в прямом порядке следования
	count - переменная,используемая в циклах выделения памяти под  текст ошибок,удаление выделенной памяти ,вывода на консоль текста ошибок
	*/
	setlocale(LC_ALL, "Russian");//установка текущей локали
	wprintf(L"Программа \"XML -валидатор.\"\n");
	
	wcscpy(Name,EncodingType());//Определение кодировки файла
	if (wcslen(Name))
		FileRead(Name);//вызов функции чтения файла
	Size_Err_Stack = GetSizeStack(&Error_Stack);//посчет количества элементов содержащихся в стеке ошибок
	buf = (wchar_t**)malloc(sizeof(wchar_t*)*(Size_Err_Stack+1));//выделение памяти под массив строк для записи ошибок
	
	for (count = 0; count != Size_Err_Stack;count++)//Цикл извлечение ошибок из стека ошибок и упорядочивание их в прямом порядке 
	{
		buf[count] = (wchar_t*)malloc(sizeof(wchar_t)*(wcslen( ShowElement(&Error_Stack)->data) + 1));//выделение памяти под строку ошибки
		wcscpy(buf[count], ShowElement(&Error_Stack)->data);//извлечение ошибки из стека ошибок и запись в массив строк
		Pop(&Error_Stack);
	}
	for (count = Size_Err_Stack-1; count != -1; count--)//цикл печати ошибок на консоль
	{
		wprintf(L"%s\n\n",buf[count]);
	}
	for (count = 0; count != Size_Err_Stack; count++)//цикл удаления памяти ,выделенной под строки в массиве ошибок
		free(buf[count]);
	free(buf);//удаления массива строк ошибок
	system("pause");
	return 0;
}
void ParseComment(FILE *fin)//функция осуществляет валидацию комментариев
//Принимает:fin - указатель на читаемый файл 
{
	wchar_t c = 0, c_ = 0, buf[200] = { 0 }, *b = buf, buf_error[200] = {0};
	unsigned count = 0;
	/*
	c - текущий прочитанный элемент из файла
	c_ - предыдущий прочитанный элемент из файла
	b - указатель для записи прочитанных символов в строки
	count - счетчик символов '-' в закрывающем теге
	buf - локальный буфер куда записыается предполагаемо закрывающий тег
	buf_error - буфер для строки ошибки ,которая добавляется в стек ошибок
	*/
	while (c != WEOF)//цикл чтения файла 
	{
		c = fgetwc(fin);
		if (c == L'\n')//проверка  на символ переноса строки
			Line++;//увеличение значения счетчика строк
		if ((c == '-') && ((c_ != '-')))//проверка на начало закрытия комментария
		{
			b = buf;//установка указателя на начало буфера для запси лексемы закрывающей комментарий
			*b = 0;
		}
		else if ((c_ == '>')||((c_ == '-')&&(c != '-')&&(c != '>')))// проверка на ошибку в закрытии комментария
		{
			*b = 0;
			if ((!wcsstr(buf, L"-->")) && (wcsstr(buf, L"--")))//проверка на пропуск в закрытии комментария символа '>'
			{
				swprintf(buf_error, 200, L"Строка#%d Ошибка:ошибка при закрытии комментария  %s", Line, buf);
				//запись текста ошибки в строку
				Push(&Error_Stack, buf_error);
				//Добавление ошибки в стек ошибок

			}
			else if (wcsstr(buf, L"-->"))//проерка на лишние символы '-' в закрытии комментария
			{
				b = buf;//устанавлтваем указатель на начало буфера
				while (*b != L'>')//цикл подсчета символов '-' при закрытии комментария
				{
					if (*b++ == '-')
						count++;
				}
				if (count > 2)//проерка на ошибочное кол-во символов '-' в призакрытии комментария
				{
					swprintf(buf_error, 200, L"Строка#%d Ошибка:ошибка при закрытии комментария  %s", Line, buf);
					//запись текста ошибки в строку
					Push(&Error_Stack, buf_error);

					//Добавление ошибки в стек ошибок
					
				}
				break;
			}
			b = buf;
			*b = 0;
		}
		*b++ = c;//запись символа в буфер
		c_ = c;//сохранение предыдущего символа
	}
	
}
void ParseProlog(FILE *fin)//функция парсинга пролога и проверка  валидации его аттрибутов.
//Принимает: fin-указатель на открытый файл
//возвращает void 
{
	wchar_t c = 0, c_ = 0, buf_attribute[200] = { 0 }, *b = buf_attribute, buf_val[100] = { 0 }, buf_error[200] = { 0 };
	struct MyStack *loc_stac = NULL;
	/*
	c - текущий прочитанный элемент из файла
	c_ - предыдущий прочитанный элемент из файла
	buf_attribute - строка содержащая имя считанного аттрибута
	buf_val - строка содержащая значение аттрибута
	buf_error - буфер для строки ошибки ,которая добавляется в стек ошибок
	loc_stac - локальный стек для определения правильности расставления кавычек
	*/
	while (c != WEOF)//цикл чтения файла
	{
		c = fgetwc(fin);
		if (c == L'\n')//проверка  на символ переноса строки
			Line++;//увеличение значения счетчика строк
		if (iswalpha(c) && iswspace(c_))//условие проеряющее начало чтения имени аттрибута
		{
			b = buf_attribute;
			*b = 0;
		}
		if ((c == L'=') || (iswspace(c) && iswalpha(c_)))//условие проверяющее начало чтения значения аттрибута
		{
			*b = 0;
			if ((!wcsstr(buf_attribute, L"encoding")) && (!wcsstr(buf_attribute,L"version")) && (!wcsstr(buf_attribute, L"standalone")))
			//проверка на ошибку в имени аттрибута ,тк пролог поддерживает только определенные аттрибуты
			{
				swprintf(buf_error, 200, L"Строка#%d ошибка: ошибка в атрибуте пролога.В прологе, этот атрибут не поддерживается :%s\n", Line, buf_attribute);
				//форматная запись текста ошибки в строку
				Push(&Error_Stack,buf_error);
				//добавление ошибки в стек ошибок
			}
			else if ((wcslen(buf_attribute) != wcslen(L"encoding")) && (wcslen(buf_attribute) != wcslen(L"version")) && (wcslen(buf_attribute) != wcslen(L"standalone")))
				//проверка в случае если неправильное имя аттрибута имеет в качестве подстроки имя стандартного аттрибута пролога 
			{
				swprintf(buf_error, 200, L"Строка#%d ошибка: ошибка в атрибуте пролога.В прологе, этот атрибут не поддерживается :%s\n", Line, buf_attribute);
				//форматная запись текста ошибки в строку
				Push(&Error_Stack, buf_error);
				//добавление ошибки в стек ошибок
			}


		}
		//if (((c_ == L'=') || (iswspace(c_))) && (c == L'"'))
		if ((c == L'=') && ((iswspace(c_)) || (iswalnum(c_))))//условие считывания значения аттрибута
		{
			b = buf_val;
			*b = 0;
			
		}
		else if ((c_ != L'=') && (!iswspace(c_)) && ((NULL==ShowElement(&loc_stac)) && (c == L'"')))//условие проверяющее наличие символа'=' после имени аттрибута
		{
			swprintf(buf_error, 200, L"Строка#%d ошибка:  отсутствует символ  \" = \" в атрибуте %s\n", Line, buf_attribute);
			//форматная запись текста ошибки в строку
			Push(&Error_Stack, buf_error);
			//добавление ошибки в стек ошибок
		}
		if (c == L'"')//если текущий символ "
		{
			if (!ShowElement(&loc_stac))//Проверка отцутствия открывающей кавычки в локальном стеке
				Push(&loc_stac, L"\"");//если условие выше верно,добавление кавычки в стек
			else // если есть кавычка в стеке
			{
				*b = 0;
				Pop(&loc_stac);//вынимаем кавычку из стека
				if (wcsstr(buf_attribute, L"encoding"))// проверка является ли текущий аттрибут аттрибутом кодировки
				{
					if (!wcsstr(buf_val,Encoding))//проверка соответствия кодировки записанной в файле с кодировкой файла
						swprintf(buf_error, 200, L"Строка#%d Ошибка в кодировке %s != %s\n", Line,Encoding,buf_val);
					//запись ошибки в строку в случае несоответствия
					Push(&Error_Stack, buf_error);
					//добавление строки ошибки в стек ошибок
				}
				b = buf_attribute;//устанавливаем указатель на начало буфера имени аттрибута
				*b = 0;
			}
		}
		if (!iswspace(c))//проверка является ли текущий символ пробелом
			*b++ = c;
		if ((c == L'>') && (c_ == L'?'))//проверка на чтение конца пролога 
			break;
		if ((c == L'<') || ((c == L'>') && (c_ != L'?')))//проверка на неправильное закрытие пролога
		{
			swprintf(buf_error, 200, L"Строка#%d ошибка:  отсутствует символ \"? \" в закрывающей скобке пролога", Line);
			//запись ошибки в строку 
			Push(&Error_Stack, buf_error);
			//добавление ошибки в стек ошибок
			break;//выход из цикла чтения пролога тк предполагается ,что была принята попытка закрытия пролога
		}
		c_ = c;//сохранение предыдущего символа
	}
	if (NULL != ShowElement(&loc_stac))//проверка пуст ли локальный стек,если содержатся
	{
		swprintf(buf_error, 200, L"Стрика #%d Ошибка:ошибка в символе \"\n ", Line);
		//запись ошибки в строку 

		Push(&Error_Stack, buf_error);
		//добавление ошибки в стек ошибок
		Pop(&loc_stac); //извлечение элемента из  локального стека.
	}
}
int CheckAttribute(wchar_t**attribute_in, size_t index, wchar_t *new_attribute)//функция проверяет наличие аттрибута в переданном ей массиве строк
/*Параметры:
attribute_in - массив строк
index - кол-во строк в массиве
new_attribute - новый считанный аттрибут,переданый в функцию для проверки наличия данного аттрибута в массиве строк
Возвращемое значение:
Если аттрибут new_attribute найден в массиве строк то 0 ,если не найден то 1
*/
{
	size_t count = 0;//счетчик для цикла проверки наличия аттрибута в массиве строк
	for (count = 0; count != index; count++)//для цикл проверки наличия аттрибута в массиве строк
	{
		if (wcsstr(attribute_in[count], new_attribute) && (wcslen(attribute_in[count]) == wcslen(new_attribute)))
			return 0;
	}
	return 1;
}
size_t ParseAttribute(FILE *fin,wchar_t *Element)
//Функция валидации аттрибутов элемента.Параметры:fin - указатель на считываемый файл
//Возврвщает size_t.Возвращаемое значение функции:0 - если аттрибуты прочитанны до символа >,1 - если отцутствует в  элементе закрывающая скобка > 
{
	wchar_t buf[200] = { 0 }, *b = buf, c = 0, c_ = 0, **buf_attribute = 0, **tmp_buf_attribute = 0, buf_val[100] = { 0 };
	size_t size = 0, index  = 0,count = 0, rez = 0;
	wchar_t buf_error[200] = { 0 } ;
	struct MyStack *loc_stac = NULL,*tmp_ptr = NULL;
	/*
	c - текущий прочитанный элемент из файла
	c_ - предыдущий прочитанный элемент из файла
	tmp_buf_attribute - указалель на дыумерный массив строк,для сохранения имен аттрибутов
	size - текущий размер массива строк
	index - номер текущей строки
	count - счетчик ,использующийся в цикле для увеличения памяти массива строк
	buf_attribute - строка содержащая имя считанного аттрибута
	buf_val - строка содержащая значение аттрибута
	buf_error - буфер для строки ошибки ,которая добавляется в стек ошибок
	loc_stac - локальный стек для определения правильности расставления кавычек
	rez - переменная в которую сохраняется значение функции,0 - если аттрибуты прочитанны до символа >,1 - если отцутствует в  элементе закрывающая скобка > 
	*/
	while (c != WEOF)//цикл чтения из файла 
	{
		c = fgetwc(fin);
		if (c == L'\n')//проверка  на символ переноса строки
			Line++;//увеличение значения счетчика строк

		if (iswalpha(c) && iswspace(c_))//условие проеряющее начало чтения имени аттрибута
		{
			b = buf;
			*b = 0;
		}

		if ((c == L'=') || (iswspace(c) && iswalpha(c_)))//условие проверяющее начало чтения значения аттрибута
		{
			*b = 0;
			if (size == 0)//проверка на наличие элементов в массиве строк
			{
				size = 10;// установка начального кол-ва элемента в массиве строк 
				buf_attribute = (wchar_t**)malloc(sizeof(wchar_t*)*size);//выделение памяти под массив указателей на строки
					buf_attribute[index] = (wchar_t*)malloc(sizeof(wchar_t)*(wcslen(buf)+1));//выделение памяти под строку ,содержащую имя аттрибута
				wcscpy(buf_attribute[index], buf);//копирование в массив имя аттрибута
				index++;//увеличение счетчика текущей строки
			}
			else if (!CheckAttribute(buf_attribute,index,buf))//Проверка наличия считанного аттрибута в массиве строк
			{
				swprintf(buf_error, 200, L"Строка#%d Ошибка: повторяющееся имя аттрибута:%s в элементе %s", Line, buf, Element);
				Push(&Error_Stack, buf_error);
			}
			if (index >= (size-1))//Проверка переполнения массива строк
			{
				//Увеличение массива строк
				size *= 2;//увеличение размера в 2 раза
				tmp_buf_attribute = (wchar_t **)malloc(sizeof(wchar_t*)*size);//выделения памяти под новый массив
				for (count = 0; count != index; count++)//цикл выделения памяти в новом массиве под строки, и копирование из старого массива
				{
					tmp_buf_attribute[count] = (wchar_t*)malloc(sizeof(wchar_t)*(wcslen(buf_attribute[count])+1));
					wcscpy(tmp_buf_attribute[count], buf_attribute[count]);
				}
				for (count = 0; count != index; count++)//////////////
					free(buf_attribute[count]);
				free(buf_attribute);//удаление старого массива

				buf_attribute = tmp_buf_attribute;//установка указателя на новую память
				tmp_buf_attribute = NULL;
				buf_attribute[index] = (wchar_t*)malloc(sizeof(wchar_t)*(wcslen(buf)+1));//выделение памяти под новую строку
				wcscpy(buf_attribute[index], buf);//запись считанного аттрибута
				index++;//увеличение счетчика текущего кол-ва строк
			}
			else if (size != 0)
			{
				buf_attribute[index] = (wchar_t*)malloc(sizeof(wchar_t)*(wcslen(buf)+1));//выделение памяти под новую строку
				wcscpy(buf_attribute[index], buf);//запись считанного аттрибута
				index++;
			}
			/////
			b = buf;
			*b = 0;
		}
		
		if ((c_ != L'=') && (!iswspace(c_)) && ((NULL == ShowElement(&loc_stac)) && (c == L'"')))//условие проверяющее наличие символа'=' после имени аттрибута
		{
			if (wcslen(buf))
			{
				swprintf(buf_error, 200, L"Строка#%d Ошибка: ошибка в аттрибуте:%s элемента %s \n", Line, buf,Element);
				Push(&Error_Stack, buf_error);
			}
			else if (index)
			{
				swprintf(buf_error, 200, L"Строка#%d Ошибка: ошибка в аттрибуте:%s элемента %s \n", Line, buf_attribute[index - 1], Element);////////////
				Push(&Error_Stack, buf_error);
			}
		}
		if (c == L'"')//если текущий символ "
		{
			tmp_ptr = ShowElement(&loc_stac);
			if (tmp_ptr == NULL)//проверка есть ли в стеке кавычки
				Push(&loc_stac, L"\"");
			else 
				Pop(&loc_stac);
		}
		if (!iswspace(c))
			*b++ = c;
		if (c == L'>')//если встретили закрывающую скобку,то конец тега.выходим из цикла
			break;
		if (c == L'<')//случай отцутсвия закрывающей скобки
		{
			swprintf(buf_error, 200, L"Строка#%d  ошибка:нет закрывающей скобкой тега в элементе %s \n", Line,Element);
			Push(&Error_Stack, buf_error);
			rez = 1;
			break;
		}
		
		c_ = c;
	}
	while (ShowElement(&loc_stac))//проверка пуст ли локальный стек,если содержатся
	{
		swprintf(buf_error, 200, L"Строка#%d Ошибка:ошибка в символе \" в элементе %s\n ", Line,Element);//запись ошибки в строку 
		Push(&Error_Stack, buf_error);
		//добавление ошибки в стек ошибок
		Pop(&loc_stac);//очищение стека

	}
	for (count = 0; count < index; count++)////////////
	{
		free(buf_attribute[count]);
	}
	free(buf_attribute);//удаление старого массива

	return rez;
}

void FileRead(wchar_t *NameFile)
//Основная функция чтения файла и определение его валидации,вызывает вспомогательные функции.Принимает void и возвращает void 

{
	FILE *f = NULL;
	size_t flag = 0;
	struct MyStack *TagsStack = NULL,*tmp_stack = NULL;
	wchar_t c = 0, c_ = 0, buf[200] = { 0 }, *b = buf, buf_error[200] = { 0 }, flag_coren_element = 0;
	/*
	c - текущий прочитанный символ из файла
	flag_coren_element - флаг коневого элемента,если его значение больше нуля значит в файле больше одного корнеого элемента
	c_ - предыдущий прочитанный символ из файла
	buf_error - буфер для строки ошибки ,которая добавляется в стек ошибок
	f - указатель на открываемый файл
	TagsStack - стек тегов,куда заносятся имена открывающих тегов и извлекаются, если находятся соответствующие закрыающие теги.
	buf - буфер куда записываются считанные символы
	b - указатель для записи символов в буфер
	*/

	if (!(f = _wfopen(NameFile, L"r")))
	{
		wprintf(L"Файл %s не найден.Перезапустите программу", NameFile);
		return;
	}

			

	while (c != WEOF)//цикл чтения из файла
	{
		c = fgetwc(f);
		if (c == L'\n')//проверка  на символ переноса строки
			Line++;//увеличение значения счетчика строк в файле

		*b++ = c;//запись считанного символа в буфер buf
		if ((c_ == L'<') && (iswalpha(c)))//условие чтения начала  тега элемента
		{
			b = buf;
			*b = 0;
			b = buf;
			*b++ = c;
			while ((!iswspace(c))&&(c != L'>'))//цикл чтения имени элемента
			{
				c = fgetwc(f);
				if (c == L'\n')
					Line++;
				if ((!iswalnum(c)) && (!iswspace(c)) && (c != L'>')&& (c!=L':') && (c!= L'_'))//проверка на использовиние недопустимых символов в теге
				{
					swprintf(buf_error, 200, L"Строка#%d ошибка:недопустимый символ в имени элемента:\" %c \"\n", Line, c);
					//запись текста ошибки в строку 
					Push(&Error_Stack, buf_error);
					//добавление строки в стек ошибок
				}
				if ((!iswspace(c)) && (iswalnum(c)) || (c == L':') || (c == L'_'))//проверка является ли записываемый символ допустимым
					*b++ = c;
			
			}
			*b = 0;
			if ((flag_coren_element == 0) && (!ShowElement(&TagsStack)))//проверка на чтение корневого элемента
				flag_coren_element++;//выставление флага корневого элемента
			else if ((flag_coren_element > 0) && (!ShowElement(&TagsStack)))//проверка на существование более одного корневого элемента
			{
				swprintf(buf_error, 200, L"Строка#%d ошибка:корневой элемент может быть только один. %s - второй корневой элемент.", Line, buf);
				//запись текста ошибки в строку 
				Push(&Error_Stack, buf_error);
				//добавление строки в стек ошибок
			}
			Push(&TagsStack, buf);
			if (c != L'>')//проверка на наличие аттрибутов у элеммента
				flag = ParseAttribute(f,buf);//вызов функции валидации аттрибутов у элемент.Выставления флага означающего отцктсвие закрывающей скобки у элемета
			b = buf;
			while (*b)*b++ = 0;
			b = buf;

		}
		else if ((c_ == L'<') && (c == L'/'))//условие обрабатывающее чтение закрывающего элемент тега
		{
			b = buf;
			*b = 0;
			b = buf;
			while (c != L'>')//условие конца чтения имени элемента
			{
				c = fgetwc(f);
				if (c == L'\n')
					Line++;//увеличение счетчика строк

				if ((iswspace(c_)) && (iswalnum(c))) 
					//проверка на недопустимое имя закрывающего тега
				{
					swprintf(buf_error, 200, L"Строка#%d ошибка: ошибка в имени закрывающего тега\n", Line);
					Push(&Error_Stack, buf_error);
				}
				if ((!iswalnum(c)) && (!iswspace(c)) && (c != L'>') && (c != L'<') && (c != L':') && (c != L'_'))
					//проерка  на недопустимые символы в имени закрывающего тэга
				{
					swprintf(buf_error, 200, L"Строка#%d ошибка:недопустимый символ в имени элемента:\" %c \"\n", Line, c);
					Push(&Error_Stack, buf_error);
				}
				if (c == L'<')//случай отцутсвия закрывающей скобки
				{
					swprintf(buf_error, 200, L"Строка#%d Строка#%d ошибка:нет закрывающей скобкой тега\n", Line -1);
					Push(&Error_Stack, buf_error);
					break;
				}
				if ((!iswspace(c)) && (iswalnum(c)) || (c == L':') || (c == L'_'))
				*b++ = c;
				c_ = c;
			}
			*b = 0;
			 tmp_stack = ShowElement(&TagsStack);
			 if (wcsstr(tmp_stack->data, buf))//сравнение считанного закрывающего тега с именем тега, лежащего в стеке
			 {
				 Pop(&TagsStack);//удаление тега из стека ,если найден закрывающий
			 }
			 else if (SearchInStack(&TagsStack,buf))//если имена открывающего тега,лежащего в стеке не совпадает именем закрыающего тега и открывающий тег элемента содержится в стеке
			 {
				do//цикл извлечения всех не закрытых элементов из стека и добавление этих элементов в стек ошибок
				 {
					tmp_stack = ShowElement(&TagsStack);
					 swprintf(buf_error, 200, L" Строка#%d Ошибка:Пропущен закрывающий тег элемента %s.\n", Line, tmp_stack->data);//запись ошибки в буфер
					 Push(&Error_Stack, buf_error);//добавление ошибки в стек ошибок
					 Pop(&TagsStack);//извлечение из стека  элемента,с отцутствующем закрывающем тегом

					 
				} while ((ShowElement(&TagsStack)) && (!wcsstr(ShowElement(&TagsStack)->data, buf)));
				Pop(&TagsStack);//излечение из стека открывающего тега элемента с именем  buf

			 }
			 else//Если открывающий тег элемента отцутствует в стеке,те ошибка была допущена в имени закрывающего  тега
			 {
				 swprintf(buf_error, 200, L" Строка#%d Ошибка:Не правльный  закрывающий тег элемента %s.\n", Line, tmp_stack->data);//запись ошибки в буфер
				 Push(&Error_Stack, buf_error);//извлечение из стека  элемента,с отцутствующем закрывающем тегом
			 }
			 
			

		}
		else if (wcsstr(buf,L"<?xml"))//случай чтения пролога
		{

			ParseProlog(f);//функция валидации пролога
			//f - указатель читаемого файла
			 
			//очищение буфера buf
			b = buf;
			while(*b)*b++ = 0;
			b = buf;
		}
		else if (wcsstr(buf, L"<!--"))//случай чтения комментария
		{
			ParseComment(f);//функция валидации комментария
			//f - указатель читаемого файла

			//очищение буфера buf
			b = buf;
			while (*b)*b++ = 0;
			b = buf;
		}
		
		c_ = c;//сохранение предыдущего символа
		if (flag)//проверка значения флага 
		{
			c_ = L'<';//сохранение закрывающей скобки ,прочитанное в функции ParseAttribute
			flag = 0;//обнуление флага
		}
	}
	fclose(f);
}
void Push(struct MyStack **Stack, wchar_t *data_in)//Функция добавления элемента в стек,возврашщает void
//Прнимает Stack - адрес указателя на стек, data_in -стока данных ,которые добавляются в стек
{
	struct MyStack *tmp_stack = *Stack, *tmp_stack_prev = NULL;
	//tmp_stack - указатель на  переданный в функцию стек
	//tmp_stack_prev - указатель для сохрпнения адреса предыдущего элемента стека
	if ((*Stack) == NULL)//Проверка пуст ли стек
	{
		(*Stack) = (struct MyStack*)malloc(sizeof(struct MyStack));// выделение памяти под новый элемент стека
		(*Stack)->data = (wchar_t*)malloc(sizeof(wchar_t)*(wcslen(data_in)+1));//выделение памяти строку добаляемых данных 
		(*Stack)->Prev = NULL;//устанавлиаем указатель на предыдущий элемент стека в ноль
		(*Stack)->Next = NULL;//устанавлиаем указатель на следующий элемент стека в ноль
		wcscpy((*Stack)->data, data_in);// копирование строки данных переданных в функцию data_in в строку данных в элементе стека

	}
	else//Случай если стек не пуст
	{
		while (tmp_stack->Next != NULL)//цикл поиска вершиеы стека
			tmp_stack = tmp_stack->Next;
			
		tmp_stack->Next = (struct MyStack*)malloc(sizeof(struct MyStack));// выделение памяти под новый элемент стека
		tmp_stack->Next->data = (wchar_t*)malloc(sizeof(wchar_t)*(wcslen(data_in)+1));//выделение памяти строку добаляемых данных 
		tmp_stack->Next->Prev = tmp_stack;//устанавливаем у добавленного элемента указатель на предыдущий элемент
		tmp_stack->Next->Next = NULL; // Устанавлеваем у добавленного элеента указатель на следующий в ноль
		wcscpy(tmp_stack->Next->data, data_in);// копирование строки данных переданных в функцию data_in в строку данных в элементе стека
	}
}
struct MyStack* ShowElement(struct MyStack **Stack)
	//функция возвращающая элемент ,лежащий на вершине стека без его удаления
	//Прнимает Stack - адрес указателя на стек
{
	struct MyStack* tmp_stack = *Stack;
	//tmp_stack - указатель на  переданный в функцию стек

	if (tmp_stack == NULL)//проверка пуст ли стек
		return NULL;//если стек пуст то возвращаем нуль
	while (tmp_stack->Next != NULL)//поиск вершины стека
		tmp_stack = tmp_stack->Next;
	return tmp_stack;//возвращение элемента стека
}
wchar_t* Pop(struct MyStack **DelElement)
// функция возвращает строку даных лежащую на вершине стека и удаляет элемент
//Прнимает DelElement - адрес указателя на стек
{
	struct MyStack* tmp_stack = *DelElement;
	wchar_t str_tmp[200] = { 0 };
	//tmp_stack - указатель на  переданный в функцию стек
	//str_tmp - временная строка(буфер) для сохранения данных удаляемого элемента
	if ((*DelElement) == NULL)//проверка пуст ли стек
		return NULL;//если стек пуст возвращает ноль
	if (tmp_stack->Next == NULL )//Проверка если стек содержит один элемент
	{
		wcscpy(str_tmp, tmp_stack->data);//копироваие данных элемента во временный буфер
		free(tmp_stack);//удаление элемента
		*DelElement = NULL;//установка указателя на стек в NULL
		return str_tmp;//возврещение данных из функции
	}
	while (tmp_stack->Next != NULL)//поиск вершины стека
		tmp_stack = tmp_stack->Next;
	if (tmp_stack->Prev != NULL)// проверка сущестования предыдущего элемента
		tmp_stack->Prev->Next = NULL;//устанавливаем у предыдущего элемента указатель на следующий в NULL
	wcscpy(str_tmp, tmp_stack->data);//копироваие данных элемента во временный буфер
	free(tmp_stack);//удаление элемента
	return str_tmp;//возврещение данных из функции
}
int  SearchInStack(struct MyStack **Stack, wchar_t *buf_in)//функция проеряет содержится ли элемент buf_in в стеке,возвркщает 1 если элемент buf_in содержится в стеке,и 0 в противном случае
//Прнимает:
//Stack - адрес указателя на стек
//*buf_in - указатель на буфер ,содержащий имя элемента
{
	struct MyStack *tmp_stack = *Stack;// установка временнного указателя tmp_stack на начало стека 
	while (tmp_stack != NULL)//цикл поиска элемента buf_in в стеке
	{
		if (wcsstr(tmp_stack->data, buf_in))//сревнение текущего элемента с искомым
			return 1;
		tmp_stack = tmp_stack->Next;// установка временного указателя tmp_stack на следующий элемент стека
	}
	return 0;

}
int  GetSizeStack(struct MyStack **Stack)// Фунукция возвращает колмчество элементов лежащих в стеке
//Прнимает в качестве параметра:
//Stack - адрес указателя на стек
{
	struct MyStack *tmp_stack = *Stack;// установка временнного указателя tmp_stack на начало стека 
	int count = 0;//count - счетчик элементов в стеке
	while (tmp_stack != NULL)//цикл подсчета элементов содержащихся в стеке
	{
		count++;//увеличение значения счетчика
		tmp_stack = tmp_stack->Next;// установка временного указателя tmp_stack на следующий элемент стека
	}
	return count;//возврещение кол-ва подсчитанных элементов

}
wchar_t *EncodingType()/// функция определяющая кодировку файла ,принимает в качестве аргумента void и записывет название определенной кодировки в глобальную переменную Encoding.Возвращает имя открытого файла
{
	FILE *f;
	union {
		unsigned flag : 11;

	} bit_flag ={0}; //битовое поле,каждый бит которого соответсвует коду символа .Если соответсвующий символ был считан из файла ,то бит отвечающий этому символу выставляется в 1,в противном случае остается равным нулю.
	/*
	 1-й бит отвечает  коду символа 0xA2
	 2-й бит отвечает  коду символа 0xA3
	 3-й бит отвечает  коду символа 0xBE
	 4-й бит отвечает  коду символа 0xD9
	 5-й бит отвечает  коду символа 0xDA
	 6-й бит отвечает  коду символа 0xDB
	 7-й бит отвечает  коду символа 0xDC
	 8-й бит отвечает  коду символа 0xD8
	 9-й бит отвечает  коду символа 0xB5
	 10-й бит отвечает  коду символа 0xDE
		11-й бит отвечает  коду символа 0xEF

	 */
		
	wchar_t c = 0, NameFile[255] = {0};
	//c - переменная в которую считывется символ из файла.
	//*f - указатель на открытый файл для чтения в бинарном режиме
	//NameFile - строка ,предназначенная для хранения имени открываемого файла
	 wprintf(L"Введите имя XML -файла:");
	 SetConsoleCP(1251);//смена кодовой страницы входного потока для ввода русских символов
	 _getws_s(NameFile, 255);
	 SetConsoleCP(866);//смена кодовой страницы входного потока на предыдущую
	 if (!(f = _wfopen(NameFile, L"rb")))// открытие файла
	 {
		 while (1)//цикл повторного открытия файла
		 {

			 wprintf(L"Файл %s не найден\n", NameFile);
			 wprintf(L"Введите имя XML -файла или EXIT для завершения программы:");
			 SetConsoleCP(1251);//смена кодовой страницы входного потока для ввода русских символов
			 _getws_s(NameFile, 255);
			 SetConsoleCP(866);//смена кодовой страницы входного потока на предыдущую
			 if (wcsstr(NameFile, L"EXIT"))
				 return "";
			 if (f = _wfopen(NameFile, L"rb"))
				 break;

		 }
	 }
	c = fgetwc(f);//считывание первых двух байт(маркера) из текстового файла ,для определения кодировка
	//определение кодировки файла
	switch (c)
	{
	case BIG_ENDIAN_MARKER://проверка маркера на BIG ENDIAN 
		fclose(f);//закрытие текстового файла
		wcscpy(Encoding,L"UTF-16 Big Endian");//сохранение типа кодировки
		return NameFile;
	case LITTLE_ENDIAN_MARKER://проверка маркера на LITTLE ENDIAN
		fclose(f);//закрытие текстового файла
		wcscpy(Encoding, L"UTF-16 Little Endian"); //сохранение типа кодировки
		return NameFile;
	case UTF_8_BOM: // проверка маркера на кодировку UTF_8(BOM)
		fclose(f); //закрытие текстового файла
		wcscpy(Encoding, L"UTF-8(BOM)"); // сохранение типа кодировки
		return NameFile;
	}
	while (c!=WEOF)//цикл чтения файла
	{
		c = fgetc(f);//считывание символа из файла
		switch (c)// switch поднимающий флаги в соответсвующих битах битового поля встретившегося символа
		{
		case KOI8_R_7:
			bit_flag.flag |= 1;//поднятие флага в 1-ом бите
			break;
		case KOI8_R_F:
			bit_flag.flag |= 2;//поднятие флага в 2-ом бите
			break;
		case KOI8_U:
			bit_flag.flag |= 4;//поднятие флага в 3-ем бите
			break;
		case ISO_rus_11:
			bit_flag.flag |= 8;//поднятие флага в 4-ом бите
			break;
		case ISO_rus_12:
			bit_flag.flag |= 16;//поднятие флага в 5-ом бите
			break;
		case ISO_rus_13:
			bit_flag.flag |= 32;//поднятие флага в 6-ом бите
			break;
		case ISO_rus_14:
			bit_flag.flag |= 64;//поднятие флага в 7-ом бите
			break;
		case OEM855_17:
			bit_flag.flag |= 128;//поднятие флага в 8-ом бите
			break;
		case OEM855_23:
			bit_flag.flag |= 256;//поднятие флага в 9-ом бите
			break;
		case OEM855_33:
			bit_flag.flag |= 512;//поднятие флага в 10-ом бите
			break;
		case OEM866_33:
			bit_flag.flag |= 1024;//поднятие флага в 11-ом бите
			break;
			
		}
		
	}
	//проверка значения битового поля
	if (((bit_flag.flag & 128) && (bit_flag.flag & 256) && (bit_flag.flag & 512)) || (bit_flag.flag & 256))//если в файле встретились кодировки смволов  0xDE-код буквы "я", 0xD8 -код буквы "п", 0xB5-код буквы "х" одновременно или только 0xB5-код буквы "х" ,то кодировка OEM 855
	{
		wcscpy(Encoding, L"OEM 855");
		fclose(f);
		return NameFile;
	}
	else if ((bit_flag.flag & 1024) && (!((bit_flag.flag & 8) && (bit_flag.flag & 16) && (bit_flag.flag & 32) && (bit_flag.flag & 64))))//если в файле есть символ 0xEF-код буквы "я" и нет символов которые определяют кодировку ISO 8859-5 ,то это OME866
	{
		wcscpy(Encoding, L"OEM 866");
		fclose(f);
		return NameFile;
	}
	else if (bit_flag.flag & 4)// если  файле встречается символ  с кодом 0xBE,присущий только кодировке KOI8-U,то кодировка файла  -KOI8-U
	{
		wcscpy(Encoding, L"KOI8-U");
		fclose(f);
		return NameFile;
	}
	else if((bit_flag.flag & 1) || (bit_flag.flag & 2))// если встретился символ с кодом 0xA2-код буквы "ё" или  0xA3-код буквы "F" , то кодировка KOI8-R
	{
		wcscpy(Encoding, L"KOI8-R");
		fclose(f);
		return NameFile;
	}
	else if ((bit_flag.flag & 8) && (bit_flag.flag & 16) && (bit_flag.flag & 32) && (bit_flag.flag & 64))//если все предыдущие условия проверок е выполнены и в файле встречаются символы с кодировкими  0xD9 -код буквы "й",0xDA-код буквы "к",0xDB-код буквы "л",0xDC - код буквы "м" ,то кодировка ISO8859-5 
	{
		wcscpy(Encoding, L"ISO8859-5");
		fclose(f);
		return NameFile;
	}
	fclose(f);//закрытие текстового файла
	return NameFile;
}